package com.bridgelabz.Utility;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;




public class Utility2 {
	
	static Scanner scanner = new Scanner(System.in);
	/**purpose : Providing logic to replace the word username
	 *           with the name passed by the user.
	 * 
	 * @param nameOfUser  passing any name from user  
	 */
	public static void nameReplacer(String nameOfUser)
	{
		if(nameOfUser.length()<3)
		{
			System.out.println("You can try entering a name with more"
					+ " than 2 characters.");
		}
		else
		{
			String greeting = "Hello UserName, How are you?";
			greeting=greeting.replace("UserName", nameOfUser);
			System.out.println(greeting);
		}
	}

	/**purpose: Logic to provide distinct triplets that sums to 0. 
	 * 
	 * @param array Entering data to calculate distinct triplets  
	 */
	public static void tripletsFinder(int[] array)
	{
		int countDistinctTriplets = 0;
		if(array.length<3)
		{
			System.out.println("Array size less than 3 so Triplets not possible");
		}
		else
		{
			for(int i=0;i<array.length-2;i++)
			{
				for(int j=i+1;j<array.length-1;j++)
				{
					for(int k=j+1;k<array.length;k++)
					{
						if(array[i]+array[j]+array[k]==0)
						{
							System.out.println("Triplets are "+array[i]+" "
						    +array[j]+" "+array[k]);
							countDistinctTriplets++;
						}
					}
				}
			}
		}
		System.out.println("Number of Distinct triplets is "+countDistinctTriplets);
		
	}
	
	public static String getString() {
		String temp = scanner.nextLine();
		return temp;
	}
	
	public static int getInteger() {
		int temp = scanner.nextInt();
		return temp;
	}
	
	public static float getFloat() {
		float temp = scanner.nextFloat();
		return temp;
	}
	
	public static double getDouble() {
		double temp = scanner.nextDouble();
		return temp;
	}
	
	public static Character getCharacter() {
		char temp = scanner.next().charAt(0);
		return temp;
	}
	
	// Doubt
	public static Object getObject()
	{
		Object tempObject = scanner.next();
		return tempObject;
	}
	
	/**
	 * @return to take rows and columns from user and return filled array
	 *         with integers   
	 */
	public static int[][] fill2DIntegerArray()
	{
		System.out.println("Enter number of rows");
		int rows = scanner.nextInt();
		System.out.println("Enter number of columns");
		int columns = scanner.nextInt();

		int[][] array = new int[rows][columns];
		System.out.println("Enter elements in array");
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				array[i][j] = scanner.nextInt();
			}
		}
		
		return array;
	}

	static PrintWriter printWriter = new PrintWriter(System.out);
	/**purpose: Logic to print the entered array using PrintWriter 
	 * 
	 * @param array Print the array with data on console 
	 */
	public static void printArray(int[][] array) {
	try {	
		
		int rows = array.length;
		int columns = array[0].length;
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				//System.out.print(array[i][j]+" ");
				printWriter.write(array[i][j]+" ");
			}
			printWriter.println();
			
			//System.out.println();
		}
		printWriter.flush();
	} catch (Exception e) {
		System.out.println(e);
	}
		
	}

	/**
	 * @return to take rows and columns from user and return filled array
	 *         with double values   
	 */
	public static double[][] fill2DDoubleArray() {
		
		System.out.println("Enter number of rows");
		int rows = scanner.nextInt();
		System.out.println("Enter number of columns");
		int columns = scanner.nextInt();

		double[][] array = new double[rows][columns];
		System.out.println("Enter elements in array");
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				array[i][j] = scanner.nextDouble();
			}
		}
		
		return array;

	}
	
	/**purpose: Logic to print the entered array using PrintWriter 
	 * 
	 * @param array Print the array with data on console 
	 */
	public static void printArrayDouble(double[][] array) {
	try {	
		int rows = array.length;
		int columns = array[0].length;
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				printWriter.write(array[i][j]+" ");
			}
			printWriter.println();
		}
		printWriter.flush();
	} 
	catch (Exception e) {
		    System.out.println(e);
	    }
		
	}
	
	/**
	 * @return to take rows and columns from user and return filled array
	 *         with boolean values   
	 */
	public static boolean[][] fill2DBooleanArray()
	{
		
		System.out.println("Enter no of rows");
		int rows = scanner.nextInt();
		System.out.println("Enter no of columns");
		int columns = scanner.nextInt();
		
		boolean[][] array = new boolean[rows][columns];
		System.out.println("Enter elements of array");
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				array[i][j]=scanner.nextBoolean();
			}
		}
		
		return array;
	}
	
	/**purpose: Logic to print the entered array using PrintWriter 
	 * 
	 * @param array Print the array with data on console 
	 */
	public static void printArrayBoolean(boolean[][] array) {
	try {	
		
		int rows = array.length;
		int columns = array[0].length;
		for(int i=0;i<rows;i++)
		{
			for(int j=0;j<columns;j++)
			{
				if(array[i][j])
				    printWriter.write("1 ");
				else
					printWriter.write("0 ");
			}
			printWriter.println();
		}
		printWriter.flush();
	}
	catch (Exception e) {
		System.out.println(e);
	   }
	}

	/**
	 * Purpose : Providing logic to check if number is prime in given range.
	 * 
	 * @param startRange starting range
	 * @param endRange ending range
	 * returns prime number in that range
	 */
	public static ArrayList<Integer> primeNumbersInRange(int startRange, int endRange) {
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
		int count=0;
		
		for(int i = startRange;i<endRange;i++)
		{
			if(i<2)
			{
				
			}
			else
			{
				for(int j=2;j<=i/2;j++)
				{
					if(i%j==0)
					{
						count++;
						break;
					}
				}
				if(count==0)
				{
					arrayList.add(i);
					//numCount++;
					//d++;
				}
				
				count=0;
//				if(d==10)
//				{
//					System.out.println();
//					d=0;
//				}
			}
		}
		return arrayList;
	}
	
	public static void isPrimeNumberPalindromeAndAnagram(ArrayList<Integer> list) {
		
		// Finding all prime numbers that are palindrome in range of 0 to 1000.
		for(Integer listContent: list)
		{
			if(isPalindrome(listContent))
			{
				System.out.println(listContent+" is Palindrome");
			}		
		}
		
		// Finding all prime numbers that are anagram in range of 0 to 1000.
		System.out.println();
		System.out.println();
		for(int i=0;i<list.size()-1;i++)
		{
			for(int j=i+1;j<list.size();j++)
			{
				String num1 = ""+list.get(i);
				String num2 = ""+list.get(j);
				
				boolean isAnagram = anagramCheck(num1, num2);
				if(isAnagram)
				{
					System.out.println(list.get(i)+" is Anagram with "+num2);
				}			
			}
		}
		
	}
		
	public static boolean isPalindrome(int num)
	{
		int temp = num;
		int reverse=0;
		
		if(noOfDigits(num)<2)
		{
			return false;
		}
		else
		{
			while(num!=0)
			{
				int remainder = num%10;
				reverse = reverse*10 + remainder;
				num = num / 10;
			}
			
			if(temp==reverse)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		
	}

	/**
	 * Purpose: providing logic to convert from farhenheit to degree celsius and
	 * vice and versa.
	 * 
	 * @param temperature Enter temperature to compute
	 * @param choice      Enter choice for specific conversion
	 * @return Result in string with the output
	 */
	public static String temperatureConvertor(double temperature, int choice) {
		double celsiusToFahrenheit;
		double fahrenheitToCelsius;

		if (choice == 1) {
			celsiusToFahrenheit = (temperature * 9 / 5) + 32;
			return "The temperature from Celsius To Fahrenheit is " + celsiusToFahrenheit;
		} else if (choice == 2) {
			fahrenheitToCelsius = (temperature - 32) * 5 / 9;
			return "The temperature from Celsius To Fahrenheit is " + fahrenheitToCelsius;
		}
		return null;

	}
	
	/**Purpose : Providing logic to find the monthly amount to be paid.
	 * 
	 * @param principal The principal loan amount taken  
	 * @param rateOfInterest Rate Of Interest at which loan needs to be paid 
	 * @param year In Number of years.
	 * @return the monthly amount to be paid
	 */
	public static double carLoanConverter(double principal, double rateOfInterest, double year) {
		double noOfMonths = 12 * year;
		double rate = rateOfInterest / (12 * 100);

		double payment = (principal * rate) / (1 - Math.pow(1 + rate, -noOfMonths));

		return payment;
	}
	
	/**Purpose : Providing logic to convert integer to Binary number
	 * 
	 * @param number to be converted into binary
	 * @return binary conversion of the entered number
	 */
	public static String integerToBinaryConverter(int number) {
		String tempString = "";
		//String result = Integer.toBinaryString(number);
		while(number!=0)
		{
			if(number%2==0)
			{
				tempString=0+tempString;
			}
			else {
				tempString=1+tempString;
			}
			number/=2;
		}
		return tempString;

	}
	
	/**Purpose : Providing logic to add the required paddings. 
	 * 
	 * @param binaryNumber to whom paddings need to be added
	 * @return the number with required padding
	 */
	public static String paddingsAdder(String binaryNumber)
	{
		int len = binaryNumber.length();
        //System.out.println(len);
        
        int padder=8-len;
        //System.out.println(padder);
        if(padder>0)
        {
        	System.out.println("Adding the required padding");
        	for(int i=0;i<padder;i++)
            {
            	binaryNumber=(0+binaryNumber)+"";
            }
        	return binaryNumber;
        }
        else
        {
        	System.out.println("No paddings needed");
        	return binaryNumber;
        }
         
	}

	/**Purpose : Providing logic to swap the nibbles and return.
	 * 
	 * @param number enter the number
	 * @return the number after swapping nibbles
	 */
	public static int nibblesSwapper(int number) {

		int result = ((number & 0x0F) << 4 | (number & 0xF0) >> 4);

		return result;
	}

	/**Purpose : Providing logic to find the square root of the entered number.
	 * 
	 * @param number whose square root you need to find
	 * @return the square root of the entered number
	 */
	public static double squareRootUsingNewtonsMethod(int number) {
		double temp = number;
		double epsilon = 1.0e-15;

		// System.out.println((epsilon * temp));
		while ((Math.abs(temp - number / temp)) > (epsilon * temp)) {
			temp = (number / temp + temp) / 2.0;
		}
		return temp;
	}

	/**Purpose : Providing logic to find total random numbers needed to
	 *           have all distinct numbers.
	 * 
	 * @param distinctCouponNumber no of distinct coupons
	 * @return total number of coupons received
	 */
	public static int distinctNumberOfCoupons(int distinctCouponNumber) {
		int distinctNumberOfCoupons = 0;
		int totalCoupons = 0;
		
		//initially isCouponCollected elements will return false
		boolean[] isCouponCollected = new boolean[distinctCouponNumber]; 
		
		while(distinctNumberOfCoupons<distinctCouponNumber)
		{
			totalCoupons++;
			int couponNumber = getCoupon(distinctCouponNumber);
			
			if(!isCouponCollected[couponNumber])
			{
				distinctNumberOfCoupons++;
				isCouponCollected[couponNumber] = true; 
			}
		}
		
		return totalCoupons;
	}

	private static int getCoupon(int distinctCouponNumber) {
		return (int)(Math.random()*distinctCouponNumber);
	}

	public static void insertionSort(int[] array) {
		int temp;
		for(int i=1;i<array.length;i++)
		{
			temp=array[i];
			int index = i;
			while(index>0&&(temp<array[index-1]))
			{
				array[index] =array[index-1];
				index --;
			}
			array[index] = temp; 
			//System.out.println(array[index]);
		}
		Utility2.printArray(array);
				
	}
	
	public static void insertionSort(String[] array) {
		String temp;
		for(int i=1;i<array.length;i++)
		{
			temp=array[i];
			int index = i;
			while(index>0&&(temp.compareTo(array[index-1]))<0)
			{
				array[index] =array[index-1];
				index --;
			}
			array[index] = temp; 
			//System.out.println(array[index]);
		}
		Utility2.printArray(array);
				
	}
	
	public static void printArray(int[] array)
	{
		//System.out.println("-------------------------------------");
		System.out.print("| ");
		for(int a: array)
		{
			System.out.print(a+" | ");
		}
		//System.out.println("\n-------------------------------------");
	}

	public static void printArray(String[] array)
	{
		//System.out.println("-------------------------------------");
		System.out.print("| ");
		for(String a: array)
		{
			System.out.print(a+" | ");
		}
		//System.out.println("\n-------------------------------------");
	}
	
	public static void bubbleSort(int[] array) {
		for(int i=0;i<array.length;i++)
		{
			for(int j=0;j<array.length-1;j++)
			{
				if(array[j]>array[j+1])
				{
					int tempVar = array[j];
					array[j] = array[j+1];
					array[j+1] = tempVar;						
				}
			}
		}
		
		Utility2.printArray(array);
		
	}
	
	public static double[] bubbleSort(double[] array) {
		for(int i=0;i<array.length;i++)
		{
			for(int j=0;j<array.length-1;j++)
			{
				if(array[j]>array[j+1])
				{
					double tempVar = array[j];
					array[j] = array[j+1];
					array[j+1] = tempVar;						
				}
			}
		}
		return array;
		
		//Utility2.printArray(array);
		
	}
	
	public static void bubbleSort(String[] array) {
		for(int i=0;i<array.length;i++)
		{
			for(int j=0;j<array.length-1;j++)
			{
				if(array[j].compareTo(array[j+1])>0)
				{
					String tempVar = array[j];
					array[j] = array[j+1];
					array[j+1] = tempVar;						
				}
			}
		}
		
		Utility2.printArray(array);
		
	}

	/**purpose: Providing logic to check whether the string to be searched
	 *          is present or absent.
	 * 
	 * @param array from which string needs to be found
	 * @param stringToBeSearched the string that needs to be searched
	 */
	public static void binarySearchStrings(String[] array, String stringToBeSearched)
	{
		
		Utility2.bubbleSort(array);
		System.out.println();
		int lowerIndex = 0;
		//System.out.println(lowerIndex);
		int higherIndex = array.length-1;
		//System.out.println(higherIndex);
		int middleIndex= (lowerIndex + higherIndex)/2;
		//System.out.println(middleIndex);
		
		while(lowerIndex<=higherIndex)
		{
			if(array[middleIndex].equals(stringToBeSearched))
			{
				System.out.println("String \""+stringToBeSearched+"\" found at "+middleIndex+" index.");
				break;
			}
			else if(array[middleIndex].compareTo(stringToBeSearched)<0)
			{
				lowerIndex = middleIndex+1;
			}
			else
			{
				higherIndex = middleIndex-1;
			}
			
			middleIndex = (lowerIndex + higherIndex)/2;
			
		}
		
		if(lowerIndex > higherIndex)
		{
			System.out.println("String not found in given array.");
		}
	
		
	}
	
	public static void binarySearch(int[] array, int numberToBeSearched)
	{
		
		Utility2.bubbleSort(array);
		System.out.println();
		int lowerIndex = 0;
		//System.out.println(lowerIndex);
		int higherIndex = array.length-1;
		//System.out.println(higherIndex);
		int middleIndex= (lowerIndex + higherIndex)/2;
		//System.out.println(middleIndex);
		
		while(lowerIndex<=higherIndex)
		{
			if(array[middleIndex]==numberToBeSearched)
			{
				System.out.println("Number \""+numberToBeSearched+"\" found at "+middleIndex+" index.");
				break;
			}
			else if(array[middleIndex]<numberToBeSearched)
			{
				lowerIndex = middleIndex+1;
			}
			else
			{
				higherIndex = middleIndex-1;
			}
			
			middleIndex = (lowerIndex + higherIndex)/2;
			
		}
		
		if(lowerIndex > higherIndex)
		{
			System.out.println("Number not found in given array.");
		}
	
		
	}
	
	/**
	 * purpose: Providing logic to check whether it is heads or tails and then
	 * calculating the % of heads vs tails count.
	 * 
	 * @param noOfCoinTosses taking the number of times user wants to flip the coin
	 * @return returning whether heads or tails and printing % of heads vs tails
	 *         count.
	 * 
	 */
	public static String headsOrTailsChecker(int noOfCoinTosses) {
		int headCounter = 0;
		int tailCounter = 0;

		for (int i = 1; i <= noOfCoinTosses; i++) {
			double coinTossValue = Math.random();
			if (coinTossValue < 0.5) {
				headCounter++;
				System.out.println("Heads");
			} else {
				tailCounter++;
				System.out.println("Tails");
			}
		}
		double headPercentage = (headCounter * 100) / noOfCoinTosses;
		double tailPercentage = (tailCounter * 100) / noOfCoinTosses;

		return "Head% = " + headPercentage + " Tail% = " + tailPercentage;
	}

	/**purpose: Provided logic to check if entered year is a leap
	 *          year or not 
	 * 
	 * @param year enter any 4 digit year between 1000 and 9999
	 * @return 
	 */
	public static boolean leapYearOrNot(int year) {
		if(year<1000||year>9999)
		{
			return false;
			
		}
		else
		{
			if(year%400==0||(year%4==0&&year%100!=0))
			{
				return true;
			}
			else 
			{
				return false;
			}
		}
	}
	
	public static int whichDayItIs(int month, int date, int year) {
		int tempYear = year - (14 - month) / 12;
		int temp = tempYear + tempYear / 4 - tempYear / 100 + tempYear / 400;
		int tempMonth = month + 12 * ((14 - month) / 12) - 2;
		int reqDay = (date + temp + (31 * tempMonth / 12)) % 7;

		return reqDay;
	}
	
	public static int dayOfTheWeekFinder(boolean value,int month,int date,int year)
	{
		int day;
		if(value)
		{
			if(month==2&&(date>=1&&date<=29))
			{
				day=whichDayItIs(month, date, year);
			}
			else if((month==4||month==6||month==9||month==11)&&(date>=1&&date<=30))
			{
				day=whichDayItIs(month, date, year);
			}
			else if((month==1||month==3||month==5||month==7||month==8||month==10||month==12)
					&&(date>=1&&date<=30))
			{
				day=whichDayItIs(month, date, year);
			}
			else {
				//System.out.println("You have entered an invalid input");
				day=-1;
			}
		}
		else
		{
			if(month==2&&(date>=1&&date<=28))
			{
				day=whichDayItIs(month, date, year);
			}
			else if((month==4||month==6||month==9||month==11)&&(date>=1&&date<=30))
			{
				day=whichDayItIs(month, date, year);
			}
			else if((month==1||month==3||month==5||month==7||month==8||month==10||month==12)
					&&(date>=1&&date<=30))
			{
				day=whichDayItIs(month, date, year);
			}
			else {
				day=-1;
				//System.out.println("You have entered an invalid input");
			}
		}
		
		return day;
		
	}

//	public static void calenderPrinterUsing2DArray(int[][] calender, int day ,int month , int year) 
//	{
//		// month number starts from 1 so 1st element 0.
//		int[] noOfDaysInAMonth = {0,31,28,31,30,31,30,31,31,30,31,30,31};
//					
//		// month number starts from 1 so 1st element empty string.
//		String[] namesOfMonths = {"","January","February","March","April","May",
//				"June","July","August","September","October","November","December"};
//					
//					
//		System.out.println("\t"+namesOfMonths[month]+"  "+year);
//		System.out.println("Sun Mon Tue Wed Thu Fri Sat");
//		
//		int i=0 ;
//		for( i=0 ;i<day; i++)
//		{
//			System.out.print("    ");
//		}
//		int tempDay = 0;
//		for(i = 0; i < calender.length; i++)
//		{
//			for(int j = 0; j < calender[i].length; j++)
//			{
//				if(noOfDaysInAMonth[month] != tempDay)
//				{
//					tempDay++;
//					if((j+day)%7==0)
//					{
//						System.out.println();
//					}
//					if(tempDay<10)
//					{
//						System.out.print("  "+tempDay+" ");
//					}
//					else
//					{
//						System.out.print(" "+tempDay+" ");
//					}
//				}
//				else 
//				{
//					break;
//				}
//			}
//		}
//	}
	
	/**
	 * purpose: Providing logic to calculate the values of 2 to the power of n.
	 * 
	 * @param valueOfN Printing the values of 2 to the power of n
	 */
	public static void powerOf2Calculator(int valueOfN) {
		if(valueOfN<0||valueOfN>30)
		{
			System.out.println("You have entered an invalid input.");
		}
		else
		{
			int powValue=1;
			for(int i=0;i<=valueOfN;i++)
			{
				System.out.println("For power "+i+" the value is "+powValue);
				powValue*=2;
			}
		}
			
		
	}
	
	/**purpose: Provided logic To find the nth Harmonic Number for the passed 
	 *          value of n .
	 * @param n any number n greater than 0.  
	 * @return harmonic value
	 */
	public static String nthHarmonicNumber(int n) {
		double sum = 0.0;
		if (n > 0) 
		{
			for (int i = 1; i <= n; i++) 
			{
				sum += 1 / (1.0 * i);
			}
		} 
		else
		{
			return "Enter valid number other than negative and 0";
		}
		return "The nth Harmonic number is = " + sum;
	}
	
	/**purpose: Provided logic To find the prime factors for the passed 
	 *          value of number .
	 * @param number number whose prime factors need to be found
	 */
	public static void primeFactorization(long number) {
		for (int i = 2; i * i <= number; i++) {
			while (number % i == 0) {
				System.out.print(i + " ");
				number = number / i;
				//System.out.println(number);
			}
		}
		if (number > 1) {
			System.out.println(number);
		} else {
			System.out.println();
		}

	}

	/**purpose : Provided logic To find the number of wins and percentage
	 *           of Win and Loss.
	 * 
	 * @param stake  Amount the gambler has
	 * @param goal  Amount the gambler wishes to win
	 * @param limit  Number of times the gambler will play
	 */
	public static void gamblingSimulator(int stake, int goal, int limit) {
		int betsMade = 0;
		int timesWon = 0;

		for (int i = 1; i <= limit; i++) {
			int cash = stake;
			while ((cash > 0) && (cash < goal)) {
				betsMade++;
				if (Math.random() > 0.5) {
					cash++;
				} else {
					cash--;
				}
			}
			if (cash == goal) {
				timesWon++;
			}
		}
		
		double percentageWins = (timesWon*100)/limit;
		double percentageLoss = ((limit-timesWon)*100)/limit;

		System.out.println("Bets made = " + betsMade + " Wins for Gambler = " + timesWon);
		System.out.println("%Wins for gambler = "+percentageWins+" %Loss for gambler ="
				+ " "+percentageLoss);
	}

	/**Purpose: providing logic to find the Euclidean Distance between the 2 points
	 *          passed by the user.
	 * 
	 * @param x enter value of x to find Euclidean Distance
	 * @param y enter value of y to find Euclidean Distance
	 * @return return the Euclidean Distance between the 2 points
	 */
	public static double euclideanDistance(int x, int y) {
		double result = Math.sqrt(x * x + y * y);

		return result;
	}
	
	/**purpose: Provided logic to calculate elapsed time using start and stop commands.
	 * 
	 */
	public static void elapsedTimeCalculator() 
	{
		long stopTimer=0;
		long startTimer=0;
		
		System.out.println("Enter start to start the stopwatch");
		String start = scanner.next();
		while(!start.equalsIgnoreCase("start"))
		{
			System.out.println("Enter \"start\" to start the stopwatch");
			start = scanner.next();
		}
		if(start.equalsIgnoreCase("start"))
		{
			startTimer = System.currentTimeMillis();
		}
		
		System.out.println("Enter stop to stop the stopwatch");
		String stop = scanner.next();
		
		while(!stop.equalsIgnoreCase("stop"))
		{
			System.out.println("Enter stop to stop the stopwatch");
			stop = scanner.next();
		}
		
		if(stop.equalsIgnoreCase("stop"))
		{
			stopTimer = System.currentTimeMillis();
		}
		
		double elapsedTime = (stopTimer-startTimer)/1000.0; 
        System.out.println("Elapsed Time = "+elapsedTime+" seconds");

	}
	
	/* Purpose: providing logic to find the value of delta using param a,b and c
	 * 
	 * @param a a to find the value of delta
	 * @param b b to find the value of delta
	 * @param c c to find the value of delta
	 * @return returning the value of delta
	 */
	public static double delta(int a, int b, int c) {
		double result = (b * b) - (4 * a * c);

		return result;
	}

	/**Purpose: providing logic to find the roots of the equation by passing value
	 * of delta b and a, and returning the result.
	 * 
	 * @param a     a to find the roots of the equation
	 * @param b     b to find the roots of the equation
	 * @param delta delta to find the roots of the equation
	 * @return returning the the roots of the equation
	 */
	public static String rootsOfEquation(int a, int b, double delta) {
		double root1OfEquation = (-b + Math.sqrt(delta)) / (2 * a);
		double root2OfEquation = (-b - Math.sqrt(delta)) / (2 * a);

		return root1OfEquation + " " + root2OfEquation;
	}

	/**Purpose: providing logic to find the value of w with the values of
	 * temperature and wind speed passed by the user.
	 * 
	 * @param temperature pass a temperature variable
	 * @param windSpeed pass a windspeed variable
	 * @return calculate windchill and return
	 */
	public static double windChillCalculator(double temperature, double windSpeed) {
		double result = 35.74 + 0.6215 * temperature + (0.4275 * temperature - 35.75) * Math.pow(windSpeed, 0.16);

		return result;
	}
	
	static List<String> permutationsRecursive = new ArrayList<>();
	/**
	 * @param stringPermutation String whose permutations need to find
	 * @param start start index of string
	 * @param end end index of string
	 */
	public static void permutationsGenerator(String stringPermutation, int start, int end) {
		
		if(start==end)
		{
			permutationsRecursive.add(stringPermutation);
			System.out.print(stringPermutation+" ");
		}
		else 
		{
			for(int i=start;i<=end;i++)
			{
				stringPermutation=swapCharacters(stringPermutation,start,i);
				permutationsGenerator(stringPermutation, start+1, end);
				stringPermutation=swapCharacters(stringPermutation,start,i);
			}
			return;
		}
		//return tempString;
	}

	/**
	 * @param stringPermutation passed string
	 * @param start index to swap with
	 * @param i index to swap with
	 * @return string with swapped characters
	 */
	private static String swapCharacters(String stringPermutation, int start, int i) {
		char[] charArray = stringPermutation.toCharArray();
	    char tempVar ;
	    tempVar = charArray[start];
	    charArray[start]=charArray[i];
	    charArray[i] = tempVar;
	    
	    return String.valueOf(charArray);
	}

	/**purpose: To compare outputs of both recursive and iterative method
	 * 
	 */
	public static void arrayComparisons()
	{
		Collections.sort(permutationsRecursive);
		Collections.sort(permutationsIterative);
		
		if(permutationsIterative.equals(permutationsRecursive))
		{
			System.out.println("Outputs for both approaches are equal");
		}
		else
		{
			System.out.println("Outputs for both approaches are not equal");
		}
	}
    
	static List<String> permutationsIterative = new ArrayList<>();
	/**
	 * @param stringPermutation1 String whose permutations need to find
	 */
	public static void permutations(String stringPermutation1) {
		char[] stringArray = stringPermutation1.toCharArray();
		//stringPermutation1.length() length of string for empty array with 0's.
		int[] temp = new int[stringPermutation1.length()];
		int i=1,j=0;
		permutationsIterative.add(String.valueOf(stringArray));
		System.out.print(stringArray);
		while(i<stringPermutation1.length())  //i<3
		{
			if(temp[i]<i)
			{
				j=(i%2)*temp[i];
				swapCharacters1(stringArray, i, j);
				permutationsIterative.add(String.valueOf(stringArray));
				System.out.print(" "+String.valueOf(stringArray));
				temp[i]++;
				i=1;
			}
			else
			{
				temp[i]=0;
				i++;
			}
		}
		
	}

	/**
	 * @param stringArray passed char array
	 * @param j index to swap with
	 * @param i index to swap with
	 */
	private static void swapCharacters1(char[] stringArray, int i, int j) {
		char temp = stringArray[j];
		stringArray[j] = stringArray[i];
		stringArray[i] = temp;
	}

	/**purpose: Provided logic to check if number valid or not 
	 *          if valid called the method to search and return value.  
	 * 
	 * @param num Passed the given number 
	 * @return the magic number user imagined
	 */
	public static int findYourMagicNumber(int num) {
		int count=0;
		   for(int i=0;i<31;i++)
		   {
			   if((num%(int)Math.pow(2, i))==0 && (num/(int)Math.pow(2, i))==1)
			   {
				   System.out.println("Number valid");
				   count++;
				   break;
				   
			   }
			   
		   }
		   
		   if(count==0)
		   {
			   //System.out.println("Enter a number whose power is raised to 2");
               return -1;   			 
		   }
		   
		   int[] array = new int[num];
		   for(int j=0 ; j < array.length ;j++)
		   {
			   array[j] = j;
		   }
		   
		   int magicNumber = Utility2.binarySearchMagicNumber(array);

		return magicNumber;
	}
	
	/**purpose: Provided logic to find the magic number using binary search .
	 * 
	 * @param array the range of numbers 
	 * @return the magic number needed
	 */
	public static int binarySearchMagicNumber(int[] array)
	{
		int lowerIndex = array[0];
		//System.out.println(lowerIndex);
		
		int higherIndex = array[array.length-1];
		//System.out.println(higherIndex);
		
		int middleIndex =(lowerIndex + higherIndex)/2;
		
		//if(middleIndex)
		while(lowerIndex<=higherIndex)
		{
			System.out.println("Enter your decision in \"yes\" if number found, else if enter \"smaller\""
					+ " or else if enter \"bigger\" than asked number.");
					
			System.out.println("Is this your number "+middleIndex);
			String decision = scanner.next();
			if(decision.equalsIgnoreCase("yes"))
			{
				return middleIndex;
			}
			else if(decision.equalsIgnoreCase("smaller"))
			{
				higherIndex=middleIndex-1;
			}
			else if (decision.equalsIgnoreCase("bigger"))
		    {
				lowerIndex=middleIndex+1;
			}
			
			middleIndex =(lowerIndex + higherIndex)/2;
		}
		
		if(lowerIndex>higherIndex)
		{
			return -1;
		}
		
		return 1;
	}
	
	/**purpose: Providing logic to sort the array of strings by first
	 *          dividing the array and then merging it to get the
	 *          sorted array
	 * 
	 * @param array for sorting
	 */
	 public static String[] intitalizeArray() {
		System.out.println("Enter the size of array");
		int arraySize = scanner.nextInt();
		while(arraySize<=0)
		{
			System.out.println("Enter the size of array greater than 0");
			arraySize = scanner.nextInt();
		}
		//To flush the scanner or else it will not accept entered elements properly
        scanner.nextLine();
		
		String[] array = new String[arraySize];
		System.out.println("Enter strings in array.");
		for(int i=0;i< array.length;i++)
		{
			array[i] = scanner.nextLine();
		}
		return array;
		
	 }
	
	 
     /**purpose: Providing logic to sort each element of the array into
     *          individual array.
     *  
     * @param array The array we have to sort
     * @param lowerIndex of array
     * @param higherIndex of array
     */
    public static void divideArray(String[] array, int lowerIndex,int higherIndex)
      {
    	  
		  if(lowerIndex==higherIndex)
		  {
			  return;    
		  }
		  
			  int middleIndex=(lowerIndex + higherIndex)/2;
			  
			  //Dividing the left side of array start from 0 to middleIndex.
			  divideArray(array, lowerIndex, middleIndex);
			  
			  //Dividing the right side of array start from middleIndex+1 to higherIndex.
			  divideArray(array, middleIndex+1,higherIndex);
			 
			  mergeArray(array, lowerIndex, middleIndex, higherIndex);
		  
		  
	  }
      
      public static void mergeArray(String[] array, int lowerIndex, int middleIndex, int higherIndex)
      {
    	  // Size of the range to be merged
    	  int n = higherIndex - lowerIndex + 1 ;
    	
    	// Storing the elements in the temporary array.
    	  String[] tempArray = new String[n];
    	  
    	  // Size of left subarray
    	  int leftSubArrayStart = 0;
    	  
    	  // Size of left subarray
    	  int rightSubArrayStart =middleIndex+1;
    	  
    	  int mergeArrayIndex = lowerIndex;
    	  
    	  while((leftSubArrayStart<=middleIndex) && (rightSubArrayStart<=higherIndex))
    	  {
    		  if(array[leftSubArrayStart].compareTo(array[rightSubArrayStart])<0)
    		  {
    			  tempArray[mergeArrayIndex]=array[leftSubArrayStart];
    			  leftSubArrayStart++;
    		  }
    		  else
    		  {
    			  tempArray[mergeArrayIndex]=array[rightSubArrayStart];
    			  rightSubArrayStart++;
    		  }
    		  mergeArrayIndex++;
    	  }
    	  
    	  //Note only one of the two while loops is executed
    	  //Copy any remaining entries of first half
    	  while(leftSubArrayStart<=middleIndex)
    	  {
    		  tempArray[mergeArrayIndex] = array[leftSubArrayStart];
    		  mergeArrayIndex++;
    		  leftSubArrayStart++;
    	  }
    	  
    	//Copy any remaining entries of second half
    	  while(rightSubArrayStart<=higherIndex)
    	  {
    		  tempArray[mergeArrayIndex] = array[rightSubArrayStart];
    		  mergeArrayIndex++;
    		  rightSubArrayStart++;
    	  }
    	  
    	  // Copying back from the temp array
    	  for(int i = 0 ; i < n ; i++)
    	  {
    		  array[ lowerIndex + i ] = tempArray[ i ];   
    	  }
      }
      
  static int count=0;
	public static int minimumNumberOfNotes(int[] arrayOfNotes, int arrayLength, int amount) {
		
		if(amount==0)
		{
			return 0;
		}
		
		int finalMinimum = Integer.MAX_VALUE;
		if(amount>0)
		{
			for(int i=arrayLength-1;i>=0;i--)
			{
				if(arrayOfNotes[i]<=amount)
				{
					count++;
					System.out.println(""+count);
					int minimum = minimumNumberOfNotes(arrayOfNotes, arrayLength, amount-arrayOfNotes[i]);
					
					if((minimum!=Integer.MAX_VALUE) && (minimum+1<finalMinimum))
					{
						finalMinimum = minimum+1;
					}
				}
				
			}
			
		}
		return finalMinimum;
	}
	
	public static int noOfDigits(int amount)
	{
		int count=0;
		while(amount!=0)
		{
			amount/=10;
			count++;
		}
		return count;
	}

	public static void vendingMachine(int amount) 
	{
		int minimumNotes=0;
		int newAmount=0;
	
		int[] notesCount = new int[8];
		int[] notesArray = {1,2,5,10,50,100,500,1000};
		
		for(int i=notesArray.length-1;i>=0;i--)
		{
			newAmount=amount%notesArray[i];
			notesCount[i] =  + amount/notesArray[i];
			amount = newAmount;
			
		}
		//System.out.println(minimumNotes);
		System.out.println("The denominations for following notes are");
		for(int i=notesArray.length-1;i>=0;i--)
		{
			minimumNotes+=notesCount[i];
			if(notesCount[i]!=0)
			{
				System.out.println(notesArray[i]+" = "+notesCount[i]);
			}
			
		}
		
		System.out.println("Total number of notes are "+minimumNotes);
		
	}
	
	/**purpose: Provide logic to check for whether strings are anagram
	 *          or not.
	 * 
	 * @param string1 string to be checked for anagram
	 * @param string2 string to be checked for anagram
	 * @return If anagram return true else false
	 */
	public static boolean anagramCheck(String string1 , String string2)
	{
		char[] charArrayString1=string1.toCharArray();
		char[] charArrayString2=string2.toCharArray();
		
		Arrays.sort(charArrayString1);
		Arrays.sort(charArrayString2);
		
		boolean anagramCheck=Arrays.equals(charArrayString1, charArrayString2);
		
		if(anagramCheck==true)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	//An empty array that holds the number of notes from 1 to 1000
	//initially all notes count are 0.
	public static int[] notesCount = new int[8];
	/**
	 * @param amount Amount passed as argument 
	 * @return 
	 */
	public static int vendor(int amount) 
	{
		// Checks the number of digits in the entered number
		int digits = Utility2.noOfDigits(amount);
		
		//If digits greater than or equal to 4 then subtract the 4 digit
		//number i.e. 1000 and increment the notesCount of every Notes
		//after recursively doing the same.
			if(digits>=4)
			{
				amount=amount-1000;
				notesCount[7]++;
				//System.out.println("1000");
				vendor(amount);
			}
			else if(digits==3)
			{
				if(amount>=500)
				{
					amount-=500;
					notesCount[6]++;
					//System.out.println("500");
				}
				else if(amount>=100)
				{
					amount-=100;
					notesCount[5]++;
					//System.out.println("100");
				}
				vendor(amount);
			}
			else if(digits==2)
			{
				if(amount>=50)
				{
					amount-=50;
					notesCount[4]++;
					//System.out.println("50");
				}
				else if(amount>=10)
				{
					amount-=10;
					notesCount[3]++;
					//System.out.println("10");
				}
				vendor(amount);
			}
			else 
			{
				if(amount>=5)
				{
					amount-=5;
					notesCount[2]++;
					//System.out.println("5");
				}
				else if(amount>=2)
				{
					amount-=2;
					notesCount[1]++;
					//System.out.println("2");
				}
				else if(amount==1)
				{
					amount-=1;
					notesCount[0]++;
					//System.out.println("1");
				}
				else if (amount==0) {
					return 0;
				}
				vendor(amount);
			}
		
		return amount;
	}
	
	public static void denominationsOfNotesPrinter()
	{
		//All the available notes
		int[] notesArray = {1,2,5,10,50,100,500,1000};

		int sum=0;

		for(int i=notesArray.length-1;i>=0;i--)
		{
			if(notesCount[i]!=0)
			{
				if(notesCount[0]!=0)
				{
					System.out.println("Total Re "+notesArray[i]+"/- notes = "+notesCount[i]);
					sum+=notesCount[i];
				}
				else
				{
					System.out.println("Total Rs "+notesArray[i]+"/- notes = "+notesCount[i]);
					sum+=notesCount[i];
				}
			}	
		}
		System.out.println("The minimum number of notes needed = "+sum);


	}

	public static boolean isPrime(int number) {
		int count = 0;
		
		if(number==0||number==1)
		{
			return false;
		}
		else
		{
			for(int i = 2; i <= number/2; i++)
			{
				if(number%i==0)
				{
					count++;
					break;
				}
			}
			if(count==0)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		
	}

	



}






















